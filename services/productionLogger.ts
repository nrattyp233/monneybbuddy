// Centralized Production Logging and Monitoring Service\n// Provides comprehensive logging, error tracking, and performance monitoring\n\nexport interface LogLevel {\n  DEBUG: 0;\n  INFO: 1;\n  WARN: 2;\n  ERROR: 3;\n  CRITICAL: 4;\n}\n\nexport interface LogEntry {\n  timestamp: string;\n  level: keyof LogLevel;\n  message: string;\n  service: string;\n  userId?: string;\n  sessionId?: string;\n  requestId?: string;\n  metadata?: Record<string, any>;\n  error?: {\n    name: string;\n    message: string;\n    stack?: string;\n  };\n  performance?: {\n    duration: number;\n    memory?: number;\n  };\n}\n\nexport interface SecurityEvent {\n  eventType: 'auth_failure' | 'rate_limit' | 'suspicious_activity' | 'data_breach_attempt' | 'privilege_escalation';\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  userId?: string;\n  ipAddress: string;\n  userAgent?: string;\n  details: Record<string, any>;\n  timestamp: string;\n}\n\nexport interface PerformanceMetric {\n  operation: string;\n  duration: number;\n  success: boolean;\n  errorType?: string;\n  userId?: string;\n  timestamp: string;\n  metadata?: Record<string, any>;\n}\n\nclass ProductionLogger {\n  private serviceName: string;\n  private isProduction: boolean;\n\n  constructor(serviceName: string) {\n    this.serviceName = serviceName;\n    this.isProduction = Deno.env.get('DENO_ENV') === 'production';\n  }\n\n  // Standard logging methods\n  debug(message: string, metadata?: Record<string, any>, userId?: string) {\n    this.log('DEBUG', message, metadata, userId);\n  }\n\n  info(message: string, metadata?: Record<string, any>, userId?: string) {\n    this.log('INFO', message, metadata, userId);\n  }\n\n  warn(message: string, metadata?: Record<string, any>, userId?: string) {\n    this.log('WARN', message, metadata, userId);\n  }\n\n  error(message: string, error?: Error, metadata?: Record<string, any>, userId?: string) {\n    const errorDetails = error ? {\n      name: error.name,\n      message: error.message,\n      stack: this.isProduction ? undefined : error.stack // Don't log stack traces in production\n    } : undefined;\n\n    this.log('ERROR', message, metadata, userId, errorDetails);\n  }\n\n  critical(message: string, error?: Error, metadata?: Record<string, any>, userId?: string) {\n    const errorDetails = error ? {\n      name: error.name,\n      message: error.message,\n      stack: error.stack // Always log stack for critical errors\n    } : undefined;\n\n    this.log('CRITICAL', message, metadata, userId, errorDetails);\n    \n    // In production, critical errors should trigger alerts\n    if (this.isProduction) {\n      this.triggerAlert(message, errorDetails, metadata);\n    }\n  }\n\n  // Security event logging\n  logSecurityEvent(event: SecurityEvent) {\n    const logEntry: LogEntry = {\n      timestamp: new Date().toISOString(),\n      level: this.mapSeverityToLevel(event.severity),\n      message: `Security Event: ${event.eventType}`,\n      service: this.serviceName,\n      userId: event.userId,\n      metadata: {\n        eventType: event.eventType,\n        severity: event.severity,\n        ipAddress: event.ipAddress,\n        userAgent: event.userAgent,\n        details: event.details\n      }\n    };\n\n    this.writeLog(logEntry);\n    \n    // High/Critical security events should trigger immediate alerts\n    if (event.severity === 'high' || event.severity === 'critical') {\n      this.triggerSecurityAlert(event);\n    }\n  }\n\n  // Performance monitoring\n  logPerformance(metric: PerformanceMetric) {\n    const logEntry: LogEntry = {\n      timestamp: new Date().toISOString(),\n      level: 'INFO',\n      message: `Performance: ${metric.operation}`,\n      service: this.serviceName,\n      userId: metric.userId,\n      performance: {\n        duration: metric.duration\n      },\n      metadata: {\n        operation: metric.operation,\n        success: metric.success,\n        errorType: metric.errorType,\n        ...metric.metadata\n      }\n    };\n\n    this.writeLog(logEntry);\n  }\n\n  // Request tracking with automatic performance monitoring\n  async trackRequest<T>(\n    operation: string,\n    handler: () => Promise<T>,\n    userId?: string,\n    metadata?: Record<string, any>\n  ): Promise<T> {\n    const startTime = Date.now();\n    const requestId = crypto.randomUUID();\n    \n    this.info(`Starting ${operation}`, { requestId, ...metadata }, userId);\n    \n    try {\n      const result = await handler();\n      const duration = Date.now() - startTime;\n      \n      this.logPerformance({\n        operation,\n        duration,\n        success: true,\n        userId,\n        timestamp: new Date().toISOString(),\n        metadata: { requestId, ...metadata }\n      });\n      \n      this.info(`Completed ${operation}`, { requestId, duration, ...metadata }, userId);\n      \n      return result;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      \n      this.logPerformance({\n        operation,\n        duration,\n        success: false,\n        errorType: error instanceof Error ? error.name : 'UnknownError',\n        userId,\n        timestamp: new Date().toISOString(),\n        metadata: { requestId, ...metadata }\n      });\n      \n      this.error(`Failed ${operation}`, error instanceof Error ? error : new Error(String(error)), \n        { requestId, duration, ...metadata }, userId);\n      \n      throw error;\n    }\n  }\n\n  private log(\n    level: keyof LogLevel,\n    message: string,\n    metadata?: Record<string, any>,\n    userId?: string,\n    error?: { name: string; message: string; stack?: string }\n  ) {\n    const logEntry: LogEntry = {\n      timestamp: new Date().toISOString(),\n      level,\n      message,\n      service: this.serviceName,\n      userId,\n      metadata,\n      error\n    };\n\n    this.writeLog(logEntry);\n  }\n\n  private writeLog(entry: LogEntry) {\n    // In production, this would typically send to a centralized logging service\n    // For now, we'll use structured console logging\n    const logOutput = {\n      ...entry,\n      // Add additional context for production debugging\n      environment: this.isProduction ? 'production' : 'development',\n      version: Deno.env.get('APP_VERSION') || 'unknown'\n    };\n\n    if (this.isProduction) {\n      // Production: JSON format for log aggregation services\n      console.log(JSON.stringify(logOutput));\n    } else {\n      // Development: Human-readable format\n      const color = this.getLogColor(entry.level);\n      console.log(`${color}[${entry.level}]\\x1b[0m ${entry.timestamp} ${entry.service}: ${entry.message}`);\n      if (entry.metadata) {\n        console.log('  Metadata:', entry.metadata);\n      }\n      if (entry.error) {\n        console.log('  Error:', entry.error);\n      }\n    }\n  }\n\n  private getLogColor(level: keyof LogLevel): string {\n    switch (level) {\n      case 'DEBUG': return '\\x1b[36m'; // Cyan\n      case 'INFO': return '\\x1b[32m';  // Green\n      case 'WARN': return '\\x1b[33m';  // Yellow\n      case 'ERROR': return '\\x1b[31m'; // Red\n      case 'CRITICAL': return '\\x1b[35m'; // Magenta\n      default: return '\\x1b[37m'; // White\n    }\n  }\n\n  private mapSeverityToLevel(severity: string): keyof LogLevel {\n    switch (severity) {\n      case 'low': return 'INFO';\n      case 'medium': return 'WARN';\n      case 'high': return 'ERROR';\n      case 'critical': return 'CRITICAL';\n      default: return 'INFO';\n    }\n  }\n\n  private async triggerAlert(message: string, error?: any, metadata?: Record<string, any>) {\n    // In production, this would integrate with alerting services (PagerDuty, Slack, etc.)\n    console.error('üö® CRITICAL ALERT:', {\n      service: this.serviceName,\n      message,\n      error,\n      metadata,\n      timestamp: new Date().toISOString()\n    });\n  }\n\n  private async triggerSecurityAlert(event: SecurityEvent) {\n    // In production, this would trigger immediate security response\n    console.error('üîê SECURITY ALERT:', {\n      service: this.serviceName,\n      event,\n      timestamp: new Date().toISOString()\n    });\n  }\n}\n\n// Health check and system monitoring\nexport class SystemMonitor {\n  private logger: ProductionLogger;\n  private startTime: number;\n\n  constructor(serviceName: string) {\n    this.logger = new ProductionLogger(`${serviceName}-monitor`);\n    this.startTime = Date.now();\n  }\n\n  getHealthStatus() {\n    const uptime = Date.now() - this.startTime;\n    const memoryUsage = typeof Deno !== 'undefined' ? Deno.memoryUsage() : undefined;\n    \n    return {\n      status: 'healthy',\n      uptime,\n      memory: memoryUsage,\n      timestamp: new Date().toISOString(),\n      version: Deno.env.get('APP_VERSION') || 'unknown'\n    };\n  }\n\n  logSystemEvent(event: string, details?: Record<string, any>) {\n    this.logger.info(`System Event: ${event}`, {\n      ...details,\n      uptime: Date.now() - this.startTime\n    });\n  }\n}\n\n// Export singleton instances for easy use\nexport const createLogger = (serviceName: string) => new ProductionLogger(serviceName);\nexport const createMonitor = (serviceName: string) => new SystemMonitor(serviceName);\n